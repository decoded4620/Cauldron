/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package com.decoded.cauldron;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import com.decoded.cauldron.api.network.http.CauldronHeaderNames;
import com.decoded.cauldron.api.network.http.CauldronHttpMethod;
import com.decoded.cauldron.api.network.http.HeaderNames;
import com.decoded.cauldron.api.network.http.MimeType;
import com.decoded.cauldron.netty.NettyCauldronServer;
import com.decoded.cauldron.server.CauldronServer;
import com.decoded.cauldron.test.util.AsyncUtils;
import com.decoded.cauldron.test.util.CauldronServerBaseTest;
import com.decoded.cauldron.test.util.LoadTestUtil;
import com.google.common.collect.ImmutableList;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import kong.unirest.HttpResponse;
import kong.unirest.JsonNode;
import kong.unirest.Unirest;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;


class CauldronHttpServerLoadTest extends CauldronServerBaseTest {
  private static final int READ_SUBMIT_RATE_PER_SEC = 0;
  private static final int WRITE_SUBMIT_RATE_PER_SEC = 0;
  private static final int ADDITIONAL_PROCESSING_LATENCY = 10;
  private static final int LOAD_TEST_PORT = 8082;
  private static final int CALL_COUNT = 500;
  private static final int START_STOP_WAIT = 2000;
  private static final int WAIT_TIME = 40000;
  private static final String RESOURCE_URI = String.format("http://localhost:%d/testNetty", LOAD_TEST_PORT);
  private static final String RESOURCE_ASYNC_URI = String.format("http://localhost:%d/testNettyAsync", LOAD_TEST_PORT);
  static CauldronServer cauldronServer;

  @BeforeAll
  static void beforeAll() {
    // load test on a new port
    cauldronServer = new NettyCauldronServer().setPort(LOAD_TEST_PORT);

    CompletableFuture<Void> startFuture = cauldronServer.start();
    System.out.println("-----------------------------START--------------------------------");
    AsyncUtils.wait(startFuture.thenAccept((v) -> {
      // assert starting
      assertFalse(cauldronServer.isStarting(), "Cauldron server is not still starting");
      assertTrue(cauldronServer.isStarted(), "Cauldron server is started");
      assertFalse(cauldronServer.isShuttingDown(), "Cauldron server is not shutting down");
    }), START_STOP_WAIT);
  }

  @AfterAll
  static void afterAll() {
    CompletableFuture<Void> stopFuture = cauldronServer.stop().thenAccept((v) -> {
      assertFalse(cauldronServer.isStarted(), "Cauldron server is stopped");
    });

    AsyncUtils.wait(stopFuture, START_STOP_WAIT);
    System.out.println("-----------------------------COMPLETE--------------------------------");
  }

  @Test
  void loadTestGet() {
    LoadTestUtil.loadTest(() -> {
      HttpResponse<JsonNode> getReq = Unirest.get(RESOURCE_URI)
          .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
          .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
          .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.GET.name())
          .header(CauldronHeaderNames.ADDITIONAL_PROCESSING_LATENCY, String.valueOf(ADDITIONAL_PROCESSING_LATENCY))
          .queryString("id", "123")
          .asJson();
      assertEquals(200, getReq.getStatus());
    }, 10, CALL_COUNT, WAIT_TIME, READ_SUBMIT_RATE_PER_SEC);
  }

  @Test
  void loadTestGetAsync() {
    LoadTestUtil.loadTest(() -> {
      HttpResponse<JsonNode> getReq = Unirest.get(RESOURCE_ASYNC_URI)
          .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
          .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
          .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.GET.name())
          .header(CauldronHeaderNames.ADDITIONAL_PROCESSING_LATENCY, String.valueOf(ADDITIONAL_PROCESSING_LATENCY))
          .queryString("id", String.valueOf(123))
          .asJson();

      assertEquals(200, getReq.getStatus());
    }, 10, CALL_COUNT, WAIT_TIME, READ_SUBMIT_RATE_PER_SEC);
  }

  @Test
  void loadTestDelete() {
    LoadTestUtil.loadTest(() -> {
      HttpResponse<JsonNode> deleteReq = Unirest.delete(RESOURCE_URI)
          .header(HeaderNames.ACCEPT, MimeType.TEXT_PLAIN.toString())
          .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
          .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.DELETE.name())
          .header(CauldronHeaderNames.ADDITIONAL_PROCESSING_LATENCY, String.valueOf(ADDITIONAL_PROCESSING_LATENCY))
          .queryString("id", "123")
          .asJson();

      assertEquals(200, deleteReq.getStatus());
    }, 10, CALL_COUNT, WAIT_TIME, WRITE_SUBMIT_RATE_PER_SEC);
  }

  @Test
  void loadTestDeleteAll() {
    LoadTestUtil.loadTest(() -> {
      HttpResponse<JsonNode> deleteReq = Unirest.delete(RESOURCE_URI)
          .header(HeaderNames.ACCEPT, MimeType.TEXT_PLAIN.toString())
          .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
          .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.DELETE_ALL.name())
          .header(CauldronHeaderNames.ADDITIONAL_PROCESSING_LATENCY, String.valueOf(ADDITIONAL_PROCESSING_LATENCY))
          .asJson();

      assertEquals(200, deleteReq.getStatus());
    }, 10, CALL_COUNT, WAIT_TIME, WRITE_SUBMIT_RATE_PER_SEC);
  }

  @Test
  void loadTestGetAll() {
    LoadTestUtil.loadTest(() -> {
      HttpResponse<JsonNode> getAllReq = Unirest.get(RESOURCE_URI)
          .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
          .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
          .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.GET_ALL.name())
          .header(CauldronHeaderNames.ADDITIONAL_PROCESSING_LATENCY, String.valueOf(ADDITIONAL_PROCESSING_LATENCY))
          .asJson();
      assertEquals(200, getAllReq.getStatus());
    }, 10, CALL_COUNT, WAIT_TIME, READ_SUBMIT_RATE_PER_SEC);
  }

  @Test
  void loadTestBatchGet() {
    LoadTestUtil.loadTest(() -> {
      HttpResponse<JsonNode> batchGetReq = Unirest.get(RESOURCE_URI)
          .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
          .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
          .queryString("ids", ImmutableList.of("123", "456"))
          .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.BATCH_GET.name())
          .header(CauldronHeaderNames.ADDITIONAL_PROCESSING_LATENCY, String.valueOf(ADDITIONAL_PROCESSING_LATENCY))
          .asJson();

      assertEquals(200, batchGetReq.getStatus());
    }, 10, CALL_COUNT, WAIT_TIME, READ_SUBMIT_RATE_PER_SEC);
  }

  @Test
  void loadTestAction() {
    LoadTestUtil.loadTest(() -> {
      Map<String, Object> queryMap = new HashMap<>();

      final int a = 0;
      final long b = 1L;
      final float c = 2.2F;
      final double d = 3.44444444444444D;
      final String e = "wooptywoop";
      final boolean f = true;
      final BigInteger g = new BigInteger("1");
      final BigDecimal h = new BigDecimal("1.1");

      queryMap.put("a", a);
      queryMap.put("b", b);
      queryMap.put("c", c);
      queryMap.put("d", d);
      queryMap.put("e", e);
      queryMap.put("f", f);
      queryMap.put("g", g);
      queryMap.put("h", h);

      HttpResponse actionReq = Unirest.post(RESOURCE_URI)
          .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
          .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
          .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.ACTION.name())
          .header(CauldronHeaderNames.ADDITIONAL_PROCESSING_LATENCY, String.valueOf(ADDITIONAL_PROCESSING_LATENCY))
          .fields(queryMap)
          .asEmpty();

      assertEquals(200, actionReq.getStatus());
    }, 10, CALL_COUNT, WAIT_TIME, WRITE_SUBMIT_RATE_PER_SEC);
  }
}
