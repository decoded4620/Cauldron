/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package com.decoded.cauldron;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import com.decoded.cauldron.api.network.http.CauldronHeaderNames;
import com.decoded.cauldron.api.network.http.CauldronHttpMethod;
import com.decoded.cauldron.api.network.http.HeaderNames;
import com.decoded.cauldron.api.network.http.MimeType;
import com.decoded.cauldron.netty.NettyCauldronServer;
import com.decoded.cauldron.server.CauldronServer;
import com.decoded.cauldron.server.http.Status;
import com.decoded.cauldron.test.util.AsyncUtils;
import com.decoded.cauldron.test.util.CauldronServerBaseTest;
import com.google.common.collect.ImmutableList;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import kong.unirest.Headers;
import kong.unirest.HttpResponse;
import kong.unirest.JsonNode;
import kong.unirest.Unirest;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;


class CauldronHttpServerTest extends CauldronServerBaseTest {
  static final int SERVER_PORT = 8081;
  static final String SERVER_URI = String.format("http://localhost:%d/testNetty", SERVER_PORT);

  static CauldronServer cauldronServer;

  @BeforeAll
  static void beforeAll() {
    cauldronServer = new NettyCauldronServer();
    CompletableFuture<Void> startFuture = cauldronServer.start();
    System.out.println("-----------------------------START--------------------------------");
    AsyncUtils.wait(startFuture.thenAccept((v) -> {
      // assert starting
      assertFalse(cauldronServer.isStarting(), "Cauldron server is not still starting");
      assertTrue(cauldronServer.isStarted(), "Cauldron server is started");
      assertFalse(cauldronServer.isShuttingDown(), "Cauldron server is not shutting down");
    }), 30000);
  }

  @AfterAll
  static void afterAll() {
    CompletableFuture<Void> stopFuture = cauldronServer.stop().thenAccept((v) -> {
      assertFalse(cauldronServer.isStarted(), "Cauldron server is stopped");
    });

    AsyncUtils.wait(stopFuture, 30000);
    System.out.println("-----------------------------COMPLETE--------------------------------");
  }

  @Test
  void testGet() {
    HttpResponse<JsonNode> getResponse = Unirest.get(SERVER_URI)
        .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
        .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.GET.name())
        .queryString("id", "123")
        .asJson();
    assertContentType(getResponse.getHeaders(), MimeType.APPLICATION_JSON);
  }

  @Test
  void testGetNoContent() {
    HttpResponse<JsonNode> getResponse = Unirest.get(SERVER_URI)
        .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
        .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.GET.name())
        .asJson();

    assertEquals(404, getResponse.getStatus());
  }


  @Test
  void testCustomErrorStatus() {
    HttpResponse<JsonNode> getResponse = Unirest.get(SERVER_URI)
        .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
        .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.GET.name())
        .header(CauldronHeaderNames.CUSTOM_ERROR_STATUS, Status.NOT_ALLOWED_405.name())
        .asJson();

    assertEquals(Status.statusOf(Status.NOT_ALLOWED_405), getResponse.getStatus());
  }

  @Test
  void testGetAsync() {
    HttpResponse<JsonNode> getAsyncResponse = Unirest.get("http://localhost:8081/testNettyAsync")
        .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
        .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.GET.name())
        .queryString("id", String.valueOf(234))
        .asJson();

    assertContentType(getAsyncResponse.getHeaders(), MimeType.APPLICATION_JSON);
  }

  @Test
  void testDelete() {
    HttpResponse<JsonNode> deleteResponse = Unirest.delete(SERVER_URI)
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.DELETE.name())
        .queryString("id", "123")
        .asJson();

    assertEmptyContentType(deleteResponse.getHeaders());
  }

  @Test
  void testDeleteAll() {
    HttpResponse<JsonNode> deleteResponse = Unirest.delete(SERVER_URI)
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.DELETE_ALL.name())
        .asJson();

    assertEmptyContentType(deleteResponse.getHeaders());
  }

  @Test
  void testGetAll() {
    HttpResponse<JsonNode> getAllResponse = Unirest.get(SERVER_URI)
        .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
        .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.GET_ALL.name())
        .asJson();

    assertContentType(getAllResponse.getHeaders(), MimeType.APPLICATION_JSON);
  }

  @Test
  void testBatchGet() {
    HttpResponse<JsonNode> batchGetResponse = Unirest.get(SERVER_URI)
        .header(HeaderNames.ACCEPT, MimeType.APPLICATION_JSON.toString())
        .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
        .queryString("ids", ImmutableList.of("123", "456"))
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.BATCH_GET.name())
        .asJson();

    assertEquals(200, batchGetResponse.getStatus());
    assertContentType(batchGetResponse.getHeaders(), MimeType.APPLICATION_JSON);
  }

  @Test
  void testAction() {
    Map<String, Object> queryMap = new HashMap<>();

    final int a = 0;
    final long b = 1L;
    final float c = 2.2F;
    final double d = 3.44444444444444D;
    final String e = "woopty woop";
    final boolean f = true;
    final BigInteger g = new BigInteger("1");
    final BigDecimal h = new BigDecimal("1.1");

    queryMap.put("a", a);
    queryMap.put("b", b);
    queryMap.put("c", c);
    queryMap.put("d", d);
    queryMap.put("e", e);
    queryMap.put("f", f);
    queryMap.put("g", g);
    queryMap.put("h", h);

    HttpResponse actionResponse = Unirest.post(SERVER_URI)
        .header(HeaderNames.ACCEPT, MimeType.TEXT_PLAIN.toString())
        .header(HeaderNames.ACCEPT_ENCODING, "gzip;q=1.0")
        .header(CauldronHeaderNames.CAULDRON_HTTP_METHOD, CauldronHttpMethod.ACTION.name())
        .fields(queryMap)
        .asEmpty();

    // we should have cookies set for this test.
    List<String> cookieHeaders = actionResponse.getHeaders().get(HeaderNames.SET_COOKIE);

    assertFalse(cookieHeaders.isEmpty());
    assertEquals(8, cookieHeaders.size());
    assertEmptyContentType(actionResponse.getHeaders());
  }

  private void assertContentType(Headers httpHeaders, MimeType mimeType) {
    assertFalse(httpHeaders.get(HeaderNames.CONTENT_TYPE).isEmpty());
    assertEquals(httpHeaders.get(HeaderNames.CONTENT_TYPE).get(0), mimeType.getMediaType());
  }

  private void assertEmptyContentType(Headers httpHeaders) {
    assertTrue(httpHeaders.get(HeaderNames.CONTENT_TYPE).isEmpty());
  }
}
